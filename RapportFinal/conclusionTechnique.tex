\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[right=2.5cm, left=2.5cm, bottom=4cm, top=3cm]{geometry}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{mathtools,amssymb,amsthm}
\usepackage{lmodern}
\usepackage{multirow}
\usepackage{array}
\usepackage{longtable}

\title{\vspace{13em}{\huge Rapport Final}}
\author{Edouard Fouassier - Maxime Gonthier - Benjamin Guillot\\
		Laureline Martin - Rémi Navarro - Lydia Rodrigez de la Nava
		\vspace{2em}\\
		Algorithme Génétique
		\vspace{2em}}

\begin{document}
	
	\pagenumbering{gobble}\clearpage
	\maketitle\vspace{13em}
\newpage
\tableofcontents
\newpage\clearpage\pagenumbering{arabic}
	\section{Conclusion technique}
		On a vu précédemment les utilisations de notre logiciel final. Nous allons maintenant parler de ses défauts et de ses possibles améliorations.\\
		Son défaut principal est qu’il n’est pas aussi générique que nous l’aurions voulu. En effet, le logiciel ne permet à l’utilisateur que d’entrer des fonctions d’adaptation qui n’ont qu’une seule variable. De ce fait, le logiciel n’est utile que dans le cas où l’on veut observer l’évolution d’une fonction à une variable.\\
		Une solution à ce problème serait de repenser le codage d’un individu pour pouvoir utiliser des fonctions fitness à plusieurs variables. Disons par exemple qu’on cherche à trouver le plus court chemin entre 5 points. Il faudrait dans ce cas un individu dans lequel 5 points sont concaténés et où le crossover se ferait donc entre ces points. Ceci est seulement un exemple, le choix est vaste quant au codage d’un individu, mais c’est un codage qui permet de trouver des solutions à de nombreux problèmes. On peut, par exemple, créer de la musique, où chaque bloc d’un individu serait une note.  Nous pensons donc que le manque de généricité du programme pourrait être résolu en revoyant le codage d’un individu. Cette information n’est malheureusement pas ressortie dans la plupart de nos recherches sur le sujet, donc nous ne l’avons pas prise en compte lors de notre réflexion.\\
		En termes d’efficacité, notre programme n’est pas parfait. Nous avons été surtout freinés par la mémoire.\\
		Par exemple, le programme serait plus efficace si la taille de la population était plus grande. Il en va de même pour l’individu : la première amélioration de l’individu serait de ne plus limiter un gène à 0 ou 1, puisqu’ils sont implémentés comme entiers, mais de laisser choisir à l’utilisateur la taille maximum d’un gène. Ainsi, nous n’utiliserions pas 4 octets en mémoire pour un seul bit.
		Le code aussi pourrait être facilement amélioré. Par exemple, on pourrait faire plutôt un tri rapide dans la fonction de tri de la population qui sert à l’évaluation des individus. La complexité de l’algorithme serait donc moindre. Cependant d’autres fonctions plus délicates et fondamentales requéraient notre attention et nous avons décidé de ne pas effectuer cette modification qui n'était pas indispensable au bon fonctionnement de l’application.\\
		De plus, le code de la fonction estParsable est très volumineux (+ de 100 lignes) cela aurait pu être réduit en divisant la fonction par exemple où en effectuant les tests de manière plus concise.\\
		De la même façon, la lecture du fichier de statistiques dans le test de convergence peut également être améliorée afin de ne lire que les statistiques voulues et non pas tout le fichier.\\
		Pour l'écriture des fichiers .ps et .fig, il aurait sûrement été plus optimisé de ne pas avoir a passer par des lignes de commandes. Cependant nous n’avons pas réussi autrement.\\
\end{document}







   
